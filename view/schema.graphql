
enum RBAC {
    QUERY

    RESET
    RESTART_STOP
}

directive @HasRbacDomain(rbac: RBAC!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Query {
  namespaces(name: String): [Namespace]!

  kmakeObjects(namespace: String! @HasRbacDomain(rbac: QUERY), name: String): [KmakeObject]!
  kmakeschedulers(namespace: String! @HasRbacDomain(rbac: QUERY), name: String, monitor: String): [KmakeScheduler]!

  kmakes(namespace: String! @HasRbacDomain(rbac: QUERY), kmake: String): [Kmake]!
  kmakeruns(namespace: String! @HasRbacDomain(rbac: QUERY), kmake: String, jobtype: JobType, kmakerun: String): [KmakeRun]!
  kmakescheduleruns(namespace: String! @HasRbacDomain(rbac: QUERY), kmake: String, kmakerun: String, kmakescheduler: String, name: String, runtype: RunType): [KmakeScheduleRun]!

}

input NewReset {
  namespace: String! @HasRbacDomain(rbac: RESET)
  kmakescheduler: String!
  full: Boolean!
}

input RunLevelIn {
  namespace: String! @HasRbacDomain(rbac: RESTART_STOP)
  kmakerun: String!
  kmakescheduler: String!
}

input SubNamespace {
  namespace: String!
}

# JWT
input NewJwt {
  user: String!
  roles: [String!]!
}

type Mutation {
  reset(input: NewReset!): KmakeScheduleRun!
  stop(input: RunLevelIn!): KmakeScheduleRun!
  restart(input: RunLevelIn!): KmakeScheduleRun!

  # JWT mutations
  createJwt(input: NewJwt!): String!
}

type Subscription {
  changed(input: SubNamespace): KmakeObject!
}

type Namespace {
  name: String!
  kmakes(name: String): [Kmake]!
}

enum JobType {
  JOB
  DUMMY
  FILEWAIT
}

enum RunType {
	START
	RESTART
	STOP
	DELETE
	CREATE
	RESET
	FORCE
}

type Kmake implements KmakeObject{
  name: String!
  namespace: String!
  status: String!
  variables: [KV]!
  rules: [Rule]!
  runs(jobtype: JobType, name: String): [KmakeRun]!
  uid: String
}

type KV {
  key: String!
  value: String!
}

type Rule {
  targets:       [String]!
  doublecolon:   Boolean!
  commands:      [String]!
  prereqs:       [String]!
  targetpattern: String!
}

type KmakeRun implements KmakeObject {
  name: String!
  namespace: String!
  status: String!
  kmakename: String
  operation: KmakeRunOp
  schedulerun(kmakescheduler: String, name: String, runtype: RunType): [KmakeScheduleRun]
  uid: String
}

type KmakeRunJob implements KmakeRunOp{
  dummy: String!
  targets: [String]!
  image: String!
  command: [String]
  args: [String]
}

type KmakeRunDummy implements KmakeRunOp{
  dummy: String!
}

type KmakeRunFileWait implements KmakeRunOp{
  dummy: String!
  files: [String!]
}

type KmakeScheduleRun implements KmakeObject{
  name: String!
  namespace: String!
  status: String!
  kmakename: String
  kmakerunname: String
  kmakeschedulename: String
  operation: KmakeScheduleRunOp!
  uid: String
}

type KmakeScheduleRunStart implements KmakeScheduleRunOp {
    dummy: String!
}

type KmakeScheduleRunRestart implements KmakeScheduleRunOp {
  dummy: String!
	run: String!
}

type KmakeScheduleRunStop implements KmakeScheduleRunOp {
  dummy: String!
	run: String!
}

type KmakeScheduleDelete implements KmakeScheduleRunOp {
  dummy: String!
}

type KmakeScheduleCreate implements KmakeScheduleRunOp {
  dummy: String!

}

type KmakeScheduleReset implements KmakeScheduleRunOp {
  dummy: String!
	recurse: String!
	full:    String!
}

type KmakeScheduleForce implements KmakeScheduleRunOp {
  dummy: String!
	operation: String!
	recurse:   String!
}

type KmakeNowScheduler implements KmakeScheduler & KmakeObject{
	name: String
	namespace: String
  status: String
	variables: [KV]
	monitor: [String]
  scheduleruns( kmake: String, kmakerun: String, name: String, runtype: RunType): [KmakeScheduleRun]!
  uid: String
}

interface KmakeScheduler {
	name: String
	namespace: String
  status: String
	variables: [KV]
	monitor: [String]
  uid:  String
}

interface KmakeObject {
	name: String
	namespace: String
  status: String
  uid: String
}

interface KmakeRunOp {
  dummy: String
}

interface KmakeScheduleRunOp {
  dummy: String
}
